# WPO网站性能优化进阶
## 目录
1. [理解Ajax性能](#a)
2. [创建快速响应的web应用](#b)
	* [用户的等待](#b1)
	* [内存使用对响应时间影响的解决方案](#b2)
	* [多线程](#b3)
3. [拆分初始化负载](#c)
4. [无阻塞加载脚本](#d)
5. [整合异步脚本](#e)
    * [异步加载脚本时保持执行顺序(单个脚本)](#e1)
    * [多个脚本](#e2)
    * [综合解决方案](#e3)
    * [互联网中国年的异步加载](#e4)
6. [行内脚本](#f)
7. [编写高效的JavaScript](#g)
	
<a name="a"></a>
# 理解Ajax性能
> 当我们做性能优化的时候，不要浪费时间去尝试为那些不消耗大量时间的代码提速，评估优先，拒绝任何不能提供良好效益的优化。炫酷特效应该只在确实能改善用户体验时才使用，而不应用与炫耀或弥补功能或可用性上的缺陷。
> 浏览器通常在运行javascript上花费很少（javascript应避免不必要的循环嵌套），绝大部分时间消耗在DOM上。善于利用ajax技术使程序运行更快。

<a name="b"></a>
# 创建快速响应的web应用
<a name="b1"></a>
## 用户的等待
#### 1. 0.1秒：用户直接操作UI对象的感觉极限。比如：选中的时候高亮文本。
#### 2. 1秒：用户随意地在进行操作而无需过度等待的感觉极限。0.2～10秒的延迟会被用户注意到。(注：请在3秒内给用户反馈)
#### 3. 10秒：用户可以忍受的极限。

<a name="b2"></a>
# 内存使用对响应时间影响的解决方案

> 内存管理不善会导致UI的性能问题

## 1. 使用delete关键字从内存中移除不再需要的javascript对象

    var a = {};
    ...
    delete a;
    
## 2. 从网页的DOM树上移除不再必需的节点 

<a name="b3"></a>
# 多线程
## 1. Web Workers
## 2. Gears

<a name="d"></a>
# 无阻塞加载脚本
## 1.XHR Eval
> 该技术通过XMLHttpRequest（XHR）从服务端获取脚本，当响应完成时，通过eval命令执行内容。缺点：脚本必须部署在和页面相同页面中

    var xhtObj = getXHRObject();
    xhrObj.onreadystatechange = function() {   
        if ( xhrObj.readyState != 4 ) return;   
        eval(xhrObj.responseText);   
    };   
    xhrObj.open('GET', 'A.js', true);   
    xhrObj.send('');  

    function getXHRObject() {
        var xhrObj = false;
        try {
            xhrObj = new XMLHttpRequest();
        }
        catch(e){
            var progid = ['MSXML2.XMLHTTP.5.0','MSXML2.XMLHTTP.4.0','MSXML2.XMLHTTP.3.0','MSXML2.XMLHTTP','Microsoft.XMLHTTP'];
            for(var i = 0; i < progid.length; ++i){
                try{
                    xhrObj = new ActiveXOBJect(progid[i]);
                }
                catch(e) {
                    continue;
                }
                break;
            }
        }
        finally {
            return xhrObj;
        }
    }
    
## 2.XHR 注入
> 和XHR Eval类似，要同域，不同的是该机制是通过创建一个script元素，然后把XHRHttpRequest的响应注入script中来执行JavaScript的。在某些情况下使用eval可能比这种机制慢

    var xhtObj = getXHRObject();
    xhrObj.onreadystatechange = function() {   
        if ( xhrObj.readyState != 4 ){
            var scriptElem = document.createElement('script');
            document.getElementsByTagName('head')[0].appendChild(scriptElem);
            scriptElem.text = xhrObj.responseText;
        }    
    };   
    xhrObj.open('GET', 'A.js', true);   
    xhrObj.send(''); 

## 3.Script in Iframe 
> 页面中的iframe和其他组件是并行下载的。Script in Iframe技术利用iframe无阻塞加载JavaScript。缺点：iframe是开销最大的是开销最大的DOM元素。

    <iframe src="a.html" width=0 height=0 border=0 id="iframe"></iframe>
    // 使用frames 访问主页面上的iframe
    window.frames[0].createNewDiv();
    // 使用 getElementById 访问主页面上的iframe
    document.getElementById('iframe').contentWindow.createNewDiv();
    // iframe 使用parent变量引用父页面
    function createNewDiv() {
        var newDiv = parent.document.createElement('div');
        parent.document.body.appengChild(newDiv);
    }
    
## 4.Script DOM Element
> 使用使用javascript动态创建script DOM元素并设置其src属性

    var scriptElem = document.createElement('script');
    scriptElem.src = 'http://aa.com/a.js';
    document.getElementByTagName('head')[0].appendChild(scriptElem);
    
## 5.Script Defer
> IE 支持script的 defer属性，设置该属性后允许其他资源并行下载 

    <script defer src="a.js"></script>
    
## 6.document write Script Tag
> 和Script Defer 一样,zhi zai只在 IExia下支持并行下载 

    document.write('<script src="a.js"></script>');

<a name="e"></a>
# 整合异步脚本 
<a name="e1"></a>
### 异步加载脚本时保持执行顺序（单个脚本）
> Script Onload 可能是最好的选择

#### 1.硬编码回调 
> 让外部脚本调用行内的函数 注：web开发者须能同时控制页面和外部脚本

#### 2.Window Onload 
> 通过监听window 的 onload 事件来触发行内代码的执行。这使得只要确保外部脚本在window.onload 之前下载执行就能保持顺序。有些异步加载技术能确保这点。

2.1 Script in Iframe 技术能在 IE Firefox Safari Chrome中保持执行顺序。

2.2 Script DOM Element 技术在 Firefox Safari 和 Chrome中保持执行顺序。

2.3 Script Defer 技术在 IE 中保持执行顺序。
    
    js代码嵌入menu.php里面
    <iframe src="menu.php" width=0 height=0 frameborder=0></iframe>
    <script type="text/javascript">
        function init(){
            // menu 初始化
        }
        if(window.addEventListener){
            window.addEventListener("load",init,false);
        }else if (window.attachEvent){
            window.attachEvent("onload",init)
        }
    </script>

#### 3.定时器 
> 使用轮询方法来保证在行内代码执行之前所依赖的外部脚本已经加载。setTimeout()方法

    <script type="text/javascript">
        var domscript = document.createElement('script');
        domscript.src = "munu.js";
        document.getElementsByTagName('head')[0].appendChild(domscript);

        function init(){
            Meun.init();
        }
        function initTimer(){
            if(typeof(Menu) === "undefined"){
                setTimeout(initTimer,300);
            }else {
                init();
            }
        }
        initTimer();
    </script>

#### 4.Script Onload
> Script Onload 技术是整合异步加载外部脚本和行内脚本的首选。它不引用任何外部脚本里的标识符，所以维护更简单。行内代码可以在外部脚本加载完毕后立即执行。事件处理也非常简单。

    <script type="text/javascript">
        function init(){
            Menu.init();
        }
        var domscript = document.createElement('script');
        domscript.src = "munu.js";
        domscript.onloadDone = false;
        domscript.onload = function(){
            domscript.onloadDone = true;
            init();
        }
        domscript.onreadystatechange = function(){
            if((domscript.readyState === "loaded" || domscript.readyState === "complete")&&!domscript.onloadDone){
                domscript.onloadDone = true;
                init();
            }
        }
        document.getElementsByTagName('head')[0].appendChild(domscript);
    </script>

#### 5.降级使用script 
> 更干净（只有一个script标签，而不像通常那样需要两个）；更清晰（行内代码对外部脚本的依赖更一目了然）；更安全（如果外部脚本加载失败，行内代码不会执行，避免了未定义标识符的错误）缺点：当代浏览器不支持这种写法（看到这个我要吐血了）。使用该技术需要修改外部脚本，有时还不一定做的到，所以Script Onload 是最合适的选择。

    在jquery 中加如下代码
    var scripts = document.getElementsByTagName("script");
    var cntr = scripts.length;
    while(cntr){
        var curScript = scripts(cntr - 1);
        if(curScript.src.indexOf("jquery.js") != -1){
            eval(curScript.innerHTML);
            break;
        }
        cntr --;
    }
    
    // 但jqury还不是异步加载
    <script type="text/javascript" src="jquery.js">
        $('p').html("哈哈");
    </script>

    //修改成异步加载
    <script type="text/javascript">
        function init(){
            $('p').html("哈哈");
        }
        var domscript = document.createElement('script');
        domscript.src = "jqury.js";
        if(navigator.userAgent.indexOf('Opera') != -1){
            domscript.innerHTML = "init()";
        }else {
            domscript.text = "init()";
        }
        document.getElementsByTagName('head')[0].appendChild(domscript);
    </script>

<a name="e2"></a>
### 多个脚本
> 数组queuedScripts存储执行队列中的脚本。队列中的每个脚本是一个拥有3个属性的对象；Response:XHR响应（JavaScript字符串）、Onload:脚本加载后触发的函数（可选）、bOrder:如果该脚本需要按顺序执行，则设为true(默认false)。

    <script type="text/javascript">
        EFWS.Script = {
            loadScripts:function(aUrls,onload){
                var nUrls = aUrls.length;
                var bDifferent = false;
                for(var i = 0; i < nUrls; i++){
                    if(EFWS.Script.differentDomain(aUrls[i])){
                        bDifferent = true;
                        break;
                    }
                }
                //选择最佳的加载函数
                var loadFunc = EFWS.Script.loadScriptXhrInjection;
                if(bDifferent){
                    if(navigator.userAgent.indexOf('Firefox') != -1 || navigator.userAgent.indexOf('Opera') != -1 ){
                        loadFunc = EFWS.Script.loadScriptDomElement();
                    }else {
                        loadFunc = EFWS.Script.loadScriptDocWrite;
                    }
                }
                //第二步,加载所有的脚本
                for(var i = 0; i < nUrls;i++){
                    loadFunc(aUrls[i],(i+1 == nUrls ? onload:null),true);
                }
            },
            differentDomain:function(url){
                if(url.indexOf('http://') === 0 || url.indexOf('https://') === 0){
                    var mainDomain = document.location.protocol + "://" + document.location.host + "/";
                    return (url.indexOf(mainDomain));
                }
                return false;
            },
            loadScriptDomElement: function(url,onload){
                var domscript = document.createElement('script');
                domscript.src = url;
                if(onload){
                    domscript.onloadDone = false;
                    domscript.onload = onload;
                    domscript.onreadystatechange = function(){
                        if(( domscript.readyState === "loaded" || domscript.readyState === "complete") && !domscript.onloadDone){
                            domscript.onloadDone = true;
                            domscript.onload = onload();
                        }
                    }
                }
                document.getElementByTagName('head')[0].appendChild(domscript);
            },
            loadScriptDocWrite:function(url,onload){
                document.write('<script type="text/javascript" src="'+ url +'"></script>');
                if(onload){
                    EFWS.addHandler(window,"load",onload);
                }
            },
            queuedScripts:new Array(),

            loadScriptXhrInjection:function(url,onload,bOrder){
                var iQ = EFWS.queuedScripts.length;
                if(bOrder){
                    var qScript = {response:null,onload:onload,done:false};
                    EFWS.queuedScripts[iQ] = qScript;
                }

                var xhrObj = EFWS.Script.getXHRObject();
                xhrObj.onreadystatechange = function(){
                    if( xhrObj.readyState == 4 ){
                        if(bOrder){
                            EFWS.Script.queuedScripts[iQ].response = xhrObj.responseText;
                            EFWS.Script.injectScripts();
                        }else {
                            eval(xhrObj.responseText);
                            if(onload){
                                onload();
                            }
                        }
                    }
                };
                xhrObj.open('GET',url,true);
                xhrObj.send('');
            },

            injectScripts:function() {
                var len = EFWS.Script.queuedScripts.length;
                for(var i = 0;i < len; i++){
                    var qScript = EFWS.Script.queuedScripts[i];
                    if(!qScript.done){
                        if(!qScript.response){
                            //停止！需要等待响应返回
                            break;
                        }else {
                            eval(qScript.response);
                            if(qScript.onload){
                                qScript.onload();
                            }
                            qScript.done = true;
                        }
                    }
                }
            },

            getXHRObject: function() {
                var xhrObj = false;
                try {
                    xhrObj = new XMLHttpRequest();
                }
                catch(e){
                    var aTypes = ['MSXML2.XMLHTTP.6.0','MSXML2.XMLHTTP.3.0','MSXML2.XMLHTTP','Microsoft.XMLHTTP'];
                    var len = aTypes.length;
                    for(var i = 0; i < len; ++i){
                        try{
                            xhrObj = new ActiveXOBJect(aTypes[i]);
                        }
                        catch(e) {
                            continue;
                        }
                        break;
                    }
                }
                finally {
                    return xhrObj;
                }
            }
        };

        EFWS.addHandler = function(elem,type,func){
            if(elem.addEventListener){
                elem.addEventListener(type,func,false);
            }else if(elem.attachEvent){
                elem.attachEvent("on"+type,func);
            }
        };
    </script>

#### 1.Managed XHR

    EFWS.Script.loadScriptXhrInjection("menu.js", null, true);
    EFWS.Script.loadScriptXhrInjection("menutier.js", init, true);

#### 2.Script DOM Element and Doc Write

    if ( navigator.userAgent.indexOf('Firefox') != -1 || navigator.userAgent.indexOf('Opera') != -1) {
        EFWS.Script.loadScriptDomElement("http://souders.org/efws/menu.js");
        EFWS.Script.loadScriptDomElement("http://souders.org/efws/menutier.js", init);
    }
    else {
        EFWS.Script.loadScriptDocWrite("http://souders.org/efws/menu.js");
        EFWS.Script.loadScriptDocWrite("http://souders.org/efws/menutier.js", init);
    }

> 综上所述，没有简单的跨浏览器方案可以异步加载多个脚本，还能保持执行顺序。把所有的脚本整合到一个单独的脚本中是一种值得考虑的选择。

<a name="e3"></a>
### 综合解决方案

#### 1. 单个脚本
> EFWS.script.loadScriptDomElement()实现

    EFWS.Script.loadScriptDomElement("menu.js", init);

#### 2.多个脚本 
> EFWS.Script.loadScripts() 实现

    EFWS.Script.loadScripts( ["http://souders.org/efws/menu.js", "http://souders.org/efws/menutier.js"], init);

<a name="e4"></a>
### 互联网中国年的异步加载

#### 1.google分析 和Dojo

#### 2.YUI Loader

<a name="f"></a>
### 行内脚本

#### 1.把行内脚本移至底部 
> 行内脚本阻塞并行下载和渲染

#### 2.使用异步回调启动javascript执行 

#### 3. 使用Script的defer属性


更多详情：http://stevesouders.com/efws/ 




